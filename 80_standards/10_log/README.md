# 日志

通过记录日志可以完成一些基本功能，如开发、测试期间的 Debug、故障排除、数据分析、监控告警，以及记录发生的事件等。要实现这些功能，需要 2 部分：

- 一个优秀的日志包。
- 一个日志记录规范，知道怎么更好地记录日志。

有了优秀的日志包和日志记录规范，就能很快地定位到问题，获取足够的信息，并完成后期的数据分析和监控告警，也可以很方便地进行调试了。

## 日志包

### 功能需求

支持基本的日志信息日志包需要支持基本的日志信息，包括时间戳、文件名、行号、日志级别和日志信息。

- 时间戳：可以记录日志发生的时间。在定位问题时，需要根据时间戳来复原请求过程，核对相同时间戳下的上下文，从而定位出问题。
- 文件名和行号：可以更快速定位到打印日志的位置，找到问题代码。一个日志库如果不支持文件名和行号，排查故障就会变得非常困难，基本只能靠 grep 来定位代码。通过文件名和行号，可以精准定位到问题代码，尽快地修复问题并恢复服务。
- 日志级别：通过日志级别可以知道日志的错误类型，最通常的用法是：直接过滤出 Error 级别的日志，这样就可以直接定位出问题出错点，然后再结合其他日志定位出出错的原因。如果不支持日志级别，在定位问题时，可能要查看一大堆无用的日志。
- 支持自定义配置：不同的运行环境，需要不同的日志输出配置。例如：开发测试环境为了能够方便地 Debug，需要设置日志级别为 Debug 级别。现网环境为了提高应用程序的性能，则需要设置日志级别为 Info 级别。又如，现网环境为了方便日志采集，通常会输出 JSON 格式的日志；开发测试环境为了方便查看日志，会输出 TEXT 格式的日志。所以，日志包需要能够被配置，还要不同环境采用不同的配置。
- 支持输出到标准输出和文件：日志总是要被读的，要么输出到标准输出，供开发者实时读取，要么保存到文件，供开发者日后查看。输出到标准输出和保存到文件是一个日志包最基本的功能。在分布式系统中，一个服务会被部署在多台机器上，这时候如果要查看日志，就需要分别登录不同的机器查看，非常麻烦。所以需要将日志统一投递到 Elasticsearch、Kafka 等组件上。
- 支持按级别分类输出：为了能够快速定位到需要的日志，一个比较好的做法是将日志按级别分类输出，至少错误级别的日志可以输出到独立的文件中。这样，出现问题时，可以直接查找错误文件定位问题。
- 支持结构化日志：结构化日志（Structured Logging）就是使用 JSON 或其他编码方式使日志结构化，这样可以方便后续使用 Filebeat、Logstash Shipper 等各种工具，对日志进行采集、过滤、分析和查找。
- 支持日志轮转：在一个大型 App 中，一天可能会产生几十个 G 的日志。为了防止日志把磁盘空间占满，导致服务器或者程序异常，就需要确保日志大小达到一定量级时，对日志进行切割、压缩，并转存。可以按照日志大小进行切割，也可以按日期切割。对于日志轮转功能，不建议在日志包中添加，因为这会增加日志包的复杂度，建议的做法是借助其他的工具来实现日志轮转。如在 Linux 中可以使用 Logrotate 来轮转日志，Logrotate 是一个专业的日志轮转工具。
- 支持颜色输出：在开发、测试时开启颜色输出，不同级别的日志会被不同颜色标识，这样可以很轻松地发现一些 Error、Warn 级别的日志，方便开发调试。发布到生产环境时，可以关闭颜色输出，以提高性能。
- 兼容标准库 log 包：一些早期的 Go 应用大量使用了标准库 log 包，如果日志库能够兼容标准库 log 包，就可以很容易地替换掉标准库 log 包，如 logrus 就兼容标准库 log 包。

### 日志级别

不同的日志级别代表不同的日志类型

- Error 级：说明日志是错误类型，在排障时会首先查看错误级别的日志。
- Warn 级：说明出现异常，但还不至于影响程序运行，如果程序执行的结果不符合预期，则可以参考 Warn 级别的日志，定位出异常所在。
- Info 级：可以协助 Debug，并记录一些有用的信息，供后期进行分析。通常一个日志包至少要实现 6 个级别：

| **日志级别** | **说明**                                                     |
| ------------ | ------------------------------------------------------------ |
| Debug        | Debug级别的日志主要用来提供一些Debug信息，方便我们在开发测试时，定位问题，观察程序的运行是否符合预期等 |
| Info         | Info通常是默认的日志级别，该日志级别的日志主要目的是提供一些必要的日志信息，方便在业务出现问题时，结合Error级别的日志，快速地排障 |
| Warn         | Warn级别的日志，比Info级别的日志更加重要                     |
| Error        | Error级别的日志，代表程序执行出错，如果程序正常运行，不应该产生任何Error级别的日志。Error级别的日志可以直接让我们定位到出错的原因，所以在实际的开发中，通常会把Error级别的日志输出到一个独立的文件中，方便出问题时查看 |
| Panic        | Panic级别的日志，说明错误比较严重，在输出Panic日志内容后，会调用panic(s)（s为日志内容）使程序Panic，并打印出错误堆栈，方便我们定位问题。如果程序设置了defer…recover，Panic还可以被defer…recover捕获 |
| Fatal        | Fatal级别的日志，表示程序遇到了致命的错误，需要退出。在输出日志内容后，调用os.Exit退出程序。例如，对于一个业务API，如果连接数据库失败，则可以直接调用log.Fatal打印错误，并退出程序，因为如果连接数据库失败，那我们就没法做业务的增删改查，程序没法继续执行 |

打印日志时，一个日志调用其实具有两个属性：

- 输出级别：打印日志时，期望日志的输出级别。如调用 `glog.Info("This is info message")` 打印一条日志，则输出日志级别为 Info。
- 开关级别：启动应用程序时，期望哪些输出级别的日志被打印。如使用 glog 时 -v=4 ，说明了只有日志级别高于 4 的日志才会被打印。如果开关级别设置为 L ，只有输出级别 >=L 的日志才会被打印。如开关级别为 Warn，则只会记录 Warn、Error 、Panic 和 Fatal 级别的日志。

<img src="figures/image-20221021093729333.png" alt="image-20221021093729333" style="zoom:50%;" />

## 操作规范

日志并不是越多越好，在实际开发中，经常会遇到一大堆无用的日志，却没有需要的日志。或有效的日志被大量无用的日志淹没，查找起来非常困难。一个优秀的日志包可以更好地记录、查看和分析日志，但是如何记录日志决定了能否获取到有用的信息。日志包是工具，日志记录才是灵魂。

### 打印位置

日志主要是用来定位问题的，所以要在有需要的地方打印日志：

- 在分支语句处打印日志：在分支语句处打印日志，可以判断出代码走了哪个分支，有助于判断请求的下一跳，继而继续排查问题。
- 写操作必须打印日志：写操作最可能会引起比较严重的业务故障，写操作打印日志，可以在出问题时找到关键信息。
- 在循环中打印日志要慎重：如果循环次数过多，会导致打印大量的日志，严重拖累代码的性能，建议的办法是在循环中记录要点，在循环外面总结打印出来。
- 在错误产生的最原始位置打印日志：对于嵌套的 Error，可在 Error 产生的最初位置打印 Error 日志。上层如果不需要添加必要的信息，可以直接返回下层的 Error。通过在最初产生错误的位置打印日志，可以很方便地追踪到日志的根源，进而在上层追加一些必要的信息。这可以了解到该错误产生的影响，有助于排障。另外，直接返回下层日志，还可以减少重复的日志打印。

在下面的代码中，通过在最初产生错误的位置打印日志，可以很方便地追踪到日志的根源，进而在上层追加一些必要的信息。这可以了解到该错误产生的影响，有助于排障。另外，直接返回下层日志，还可以减少重复的日志打印。

```go
package main

import (
    "flag"
    "fmt"

    "github.com/golang/glog"
)

func main() {
    flag.Parse()
    defer glog.Flush()

    if err := loadConfig(); err != nil {
        glog.Error(err)
    }
}

func loadConfig() error {
    return decodeConfig() // 直接返回
}

func decodeConfig() error {
    if err := readConfig(); err != nil {
        return fmt.Errorf("could not decode configuration data for user %s: %v", "colin", err) // 添加必要的信息，用户名称
    }

    return nil
}

func readConfig() error {
    glog.Errorf("read: end of input.")
    return fmt.Errorf("read: end of input")
}
```

### 打印级别

不同级别的日志，具有不同的意义，能实现不同的功能。在开发中，需要根据目的在合适的级别记录日志。

- Debug 级：别为了获取足够的信息进行 Debug，通常会在 Debug 级别打印很多日志。例如，可以打印整个 HTTP 请求或响应的 Body。Debug 级别需要打印大量的日志，这会严重拖累程序的性能。并且，Debug 级别的日志，主要是为了能在开发测试阶段更好地 Debug，多是一些不影响现网业务的日志信息。所以，对于 Debug 级别的日志，在服务上线时一定要禁止掉。否则，就可能会因为大量的日志导致硬盘空间快速用完，从而造成服务宕机。Debug 这个级别的日志可以随意输出，任何得有助于开发、测试阶段调试的日志，都可以在这个级别打印。
- Info 级：Info 级的日志可以记录一些有用的信息，供以后的运营分析，所以 Info 级的日志不是越多越好，也不是越少越好，应以满足需求为主要目标。一些关键日志，可以在 Info 级记录，但如果日志量大、输出频度过高，则要考虑在 Debug 级别记录。现网的日志级别一般是 Info 级，为了不使日志文件占满整个磁盘空间，在记录日志时，要注意避免产生过多的 Info 级的日志。例如，在 for 循环中，就要慎用 Info 级别的日志。
- Warn 级：一些警告类的日志可以记录在 Warn 级，Warn 级的日志往往说明程序运行异常、不符合预期，但又不影响程序的继续运行，或是暂时影响，但后续会恢复。Warn 更多的是业务级别的警告日志。
- Error 级：Error 级的日志描述程序执行出错，这些错误肯定会影响到程序的执行结果，例如请求失败、创建资源失败等。要记录每一个发生错误的日志，避免日后排障过程中这些错误被忽略掉。大部分的错误可以归在 Error 级别。
- Panic 级：Panic 级的日志在实际开发中很少用，通常只在需要错误堆栈，或不想因为发生严重错误导致程序退出，而采用 defer 处理错误时使用。
- Fatal 级：Fatal 是最高级别的日志，这个级别的日志说明问题已经相当严重，严重到程序无法继续运行，通常是系统级的错误。在开发中也很少使用，除非觉得某个错误发生时，整个程序无法继续运行。

<img src="figures/image-20221021141009654.png" alt="image-20221021141009654" style="zoom:50%;" />

### 日志内容

关于如何记录日志内容，有几条建议：

- 在记录日志时，不要输出一些敏感信息，例如密码、密钥等。
- 为了方便调试，通常会在 Debug 级别记录一些临时日志，这些日志内容可以用一些特殊的字符开头，例如 log.Debugf("XXXXXXXXXXXX-1:Input key was: %s", setKeyName) 。这样，在完成调试后，可以通过查找 XXXXXXXXXXXX 字符串，找到这些临时日志，在 commit 前删除。
- 日志内容应该小写字母开头，以英文点号 . 结尾，例如 log.Info("update user function called.") 。
- 为了提高性能，尽可能使用明确的类型，如使用 log.Warnf("init datastore: %s",  err.Error()) 而非 log.Warnf("init datastore: %v", err)  。
- 日志最好包含两个信息：一个是请求 ID（每次请求的唯一 ID），便于从海量日志中过滤出某次请求的日志，可以将请求 ID 放在请求的通用日志字段中。另一个是用户和行为，用于标识谁做了什么。
- 不要将日志记录在错误的日志级别上：例如，经常会发现有人将正常的日志信息打印在 Error 级，将错误的日志信息打印在 Info 级。

### 最佳实践

- 开发调试、现网故障排障时，不要遗忘一件事情：根据排障的过程优化日志打印。好的日志，可能不是一次就可以写好的，可以在实际开发测试，还有现网定位问题时不断优化。
- 打印日志要“不多不少”：避免打印没用的日志，也不要遗漏关键的日志信息。最好的信息是，仅凭借这些关键的日志就能定位到问题。
- 支持动态日志输出，方便线上问题定位。
- 总将日志记录在本地文件：通过将日志记录在本地文件，可以和日志中心化平台进行解耦，这样当网络不可用或日志中心平台故障时，仍然能够正常的记录日志。
- 集中化日志存储处理：因为应用可能包含多个服务，一个服务包含多个实例，为了查看日志方便，最好将这些日志统一存储在同一个日志平台上，如 Elasticsearch，方便集中管理和查看日志。
- 结构化日志记录：添加一些默认通用的字段到每行日志，方便日志查询和分析。
- 支持 RequestID：使用 RequestID 串联一次请求的所有日志，这些日志可能分布在不同的组件，不同的机器上。支持 RequestID 可以大大提高排障的效率，降低排障难度。在一些大型分布式系统中，没有 RequestID 排障简直就是灾难。
- 支持动态开关 Debug 日志：对于定位一些隐藏得比较深的问题，可能需要更多的信息，这时候可能需要打印 Debug 日志。但现网的日志级别会设置为 Info 级别，为了获取 Debug 日志，可能会修改日志级别为 Debug 级别并重启服务，定位完问题后，再修改日志级别为 Info 级别，然后再重启服务，这种方式不仅麻烦而且还可能会对现网业务造成影响。最好的办法是能够在请求中通过 debug=true 这类参数动态控制某次请求是否开启 Debug 日志。

## Lab

### 标准log包

Go 标准库 log 包的功能非常简单，只提供了 Print、Panic 和 Fatal 三类函数用于日志输出。因为是标准库自带的，所以不需要下载安装，使用起来非常方便。标准库 log 包只有不到 400 行的代码量，如果想研究如何实现一个日志包，阅读标准库 log 包是一个不错的开始。Go 的标准库大量使用了 log 包，如 net/http、net/rpc 等。

- [log print](10_log/10_print.go)
- [log fatal](10_log/20_fatal.go)
- [log panic](10_log/30_panic.go)
- [log customize](10_log/40_customize.go)

```bash
go run 10_log/10_print.go
```

```bash
go run 10_log/20_fatal.go
echo $?
```

```bash
go run 10_log/30_panic.go
```

```bash
go run 10_log/40_customize.go
```

### wklog

wklog 是一个简单的 log 包实现，demo 中主要展示了 WithLevel() 和 WithFormatter() 两个函数的设置。

- [example.go](20_wklog/example.go)

```bash
go run 20_wklog/example.go
```

### 自研 pkg/log

是个可在生产环境使用的 log 包，需要设置的配置参数为：

- `writers`：输出位置，有两个可选项 —— file 和 stdout。选择 file 会将日志记录到 `logger_file` 指定的日志文件中，选择 stdout 会将日志输出到标准输出，当然也可以两者同时选择
- `logger_level`：日志级别，DEBUG、INFO、WARN、ERROR、FATAL
- `logger_file`：日志文件
- `log_format_text`：日志的输出格式，JSON 或者 plaintext，`true` 会输出成非 JSON 格式，`false` 会输出成 JSON 格式
- `rollingPolicy`：rotate 依据，可选的有 daily 和 size。如果选 daily 则根据天进行转存，如果是 size 则根据大小进行转存
- `log_rotate_date`：rotate 转存时间，配 合`rollingPolicy: daily` 使用
- `log_rotate_size`：rotate 转存大小，配合 `rollingPolicy: size` 使用
- `log_backup_count`：当日志文件达到转存标准时，log 系统会将该日志文件进行压缩备份，这里指定了备份文件的最大个数

- [example1.go](30_rebirthmonkey-log/example1.go)
- [example2.go](30_rebirthmonkey-log/example2.go)

```bash
cd 30_rebirthmonkey-log
go run example1.go
go run example2.go
go run example2.go -l warn
```

## apiserver 示例

在原先的实例中，所有的输出都是通过 `fmt.Print()` 的方式，这样在实际生产环境中无法持久化。在生产环境中推荐使用 log 的形式输出，方便后续联调排错，详细介绍[在此](80_server/README.md)。
