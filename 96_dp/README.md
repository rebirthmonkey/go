# 设计模式

在软件开发中，经常会遇到各种各样的编码场景，这些场景往往重复发生，因此具有典型性。针对这些典型场景，可以自己编码解决，也可以采取更为省时省力的方式：直接采用设计模式。设计模式简单来说，就是将软件开发中需要重复性解决的编码场景，按最佳实践的方式抽象成一个模型，模型描述的解决方法就是设计模式。使用设计模式，可以使代码更易于理解，保证代码的重用性和可靠性。

在软件领域，GoF（四人帮，全拼 Gang of Four）首次系统化提出了 3 大类、共 25 种可复用的经典设计方案，来解决常见的软件设计问题，为可复用软件设计奠定了一定的理论基础。从总体上说，这些设计模式可以分为创建型模式、结构型模式、行为型模式 3 大类，用来完成不同的场景。

本章会介绍几个在 Go 项目开发中比较常用的设计模式，帮助用更加简单快捷的方法应对不同的编码场景。其中，简单工厂模式、抽象工厂模式和工厂方法模式都属于工厂模式。

<img src="figures/image-20221103203742194.png" alt="image-20221103203742194" style="zoom:50%;" />

## 创建型

创建型模式（Creational Patterns）提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。

### 单例模式

单例模式（Singleton Pattern）是最简单的一个模式，在 Go 中指的是全局只有一个实例，并提供一个访问该实例的全局节点。单例模式不仅有利于减少内存开支，还有减少系统性能开销、防止多个实例产生冲突等优点。因为单例模式保证了实例的全局唯一性，而且只被初始化一次，所以比较适合全局共享一个实例，且只需要被初始化一次的场景，例如数据库实例、全局配置、全局任务池等。

单例模式又分为饿汉方式和懒汉方式：

- 饿汉方式：指全局的单例实例在包被加载时创建
- 懒汉方式：指全局的单例实例在第一次被使用时创建

- [单例模式](10_singleton/main.go)：对于“饿汉模式”，因为实例是在包被导入时初始化的，所以如果初始化耗时，会导致程序加载时间比较长。懒汉方式是开源项目中使用最多的，但它的缺点是非并发安全，在实际使用时需要加锁。使用 once.Do 可以确保 ins 实例全局只被创建一次，once.Do 函数还可以确保当同时有多个创建动作时，只有一个创建动作被执行。

```bash
cd 10_singleton
go run main.go
```

### 工厂模式

工厂模式（Factory Pattern）是面向对象编程中的常用模式。在 Go 项目开发中，可以通过使用多种不同的工厂模式，来使代码更简洁明了。Go 中的结构体+方法，可以理解为面向对象编程中的类。有了 “类”，就可以创建“类”相关的实例。可以通过简单工厂模式、抽象工厂模式、工厂方法模式这 3 种方式，来创建实例。

#### 简单工厂模式

简单工厂模式是最常用、最简单的。它就是一个接受一些参数，然后返回实例的函数。参考代码案例，和 `p：=＆Person {}` 这种创建实例的方式相比，简单工厂模式可以确保创建的实例具有需要的参数，进而保证实例的方法可以按预期执行。例如，通过 NewPerson() 创建 Person 实例时，可以确保实例的 name 和 age 属性被设置。

- [简单工厂模式](20_factory/10_simple.go)

```bash
cd 20_factory
go run 10_simple.go
```

#### 抽象工厂模式

抽象工厂模式能创建一系列相关的对象，而无需指定其具体类。抽象工厂定义了用于创建不同产品的接口， 但将实际的创建工作留给了具体工厂类。 每个工厂类型都对应一个特定的产品变体。在创建产品时， 客户端代码调用的是工厂对象的构建方法， 而不是直接调用构造函数（ new操作符）。 由于一个工厂对应一种产品变体， 因此它创建的所有产品都可相互兼容。客户端代码仅通过其抽象接口与工厂和产品进行交互。 该接口允许同一客户端代码与不同产品进行交互。只需创建一个具体工厂类并将其传递给客户端代码即可。

抽象工厂模式与简单工厂模式的唯一区别，就是它返回的是接口而不是结构体。通过返回接口，可以在不公开内部实现的情况下，让调用者使用提供的各种功能。

##### Lab

- [抽象工厂模式](20_factory/20_abstract.go)

```bash
go run 20_factory/20_abstract.go
```

#### 工厂方法模式

在简单工厂模式中，依赖于唯一的工厂对象，如果需要实例化一个产品，就要向工厂中传入一个参数，获取对应的对象。但如果要增加一种产品，就要在工厂中修改创建产品的函数。这会导致耦合性过高，这时就可以使用工厂方法模式。

在工厂方法模式中，将返回工厂函数，可以通过实现工厂函数来创建多种工厂，从而将过程解耦。

##### Lab
- [工厂方法模式](20_factory/30_method.go)

```bash
go run 20_factory/30_method.go
```

### 生成器模式

生成器模式能够分步骤创建复杂对象。与其他创建型模式不同，生成器不要求产品拥有通用接口。 这使得用相同的创建过程生成不同的产品成为可能。

还是摊煎饼的[例子]()，摊煎饼分为四个步骤：1放面糊、2放鸡蛋、3放调料、4放薄脆。通过 4 个创建过程，制作好一个煎饼，这个摊煎饼的过程就好比煎饼生成器接口，不同生成器的实现就相当于摊不同品类的煎饼，比如正常的煎饼，健康的煎饼（可能用的是粗粮面、柴鸡蛋、非油炸薄脆、不放酱等），生成器接口方法也可以通过参数控制煎饼的大小，比如放两勺面糊，放2个鸡蛋等。

生成器的使用者为了避免每次都调用相同的构建步骤，也可以通过包装类固定几种构建过程，生成几类常用的产品，就好像摊煎饼有几类常卖固定成品，比如普通的，加两个鸡蛋的，不要香菜的等等，这几类固定构建过程提前定制好，直接通过简单工厂方法就直接创建，如果用户再需要细粒度的定制构建，再通过生成器创建。

### 原型模式

原型模式能够复制对象，甚至是复杂对象，而又无需使代码依赖它们所属的类。所有的原型类都必须有一个通用的接口，使得即使在对象所属的具体类未知的情况下也能复制对象。 原型对象可以生成自身的完整副本， 因为相同类的对象可以相互访问对方的私有成员变量。

在[本示例]()中，纸质文件可以通过复印机轻松拷贝出多份，设置Paper接口，包含读取文件内容和克隆文件两个方法。同时声明两个类报纸（Newspaper）和简历（Resume）实现了 Paper 接口，通过复印机（Copier）复印出两类文件的副本，并读取文件副本内容。

## 结构型

行为型模式（Behavioral Pattern），它的特点是关注类和对象的组合。

### 策略模式

策略模式（Strategy Pattern）定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。根据不同的场景，采取不同的措施，也就是不同的策略。假设需要对 a、b 这两个整数进行计算，根据条件的不同，需要执行不同的计算方式。可以把所有的操作都封装在同一个函数中，然后通过 if ... else ... 的形式来调用不同的计算方式，这种方式称之为硬编码。

在实际应用中，随着功能和体验的不断增长，需要经常添加/修改策略，这样就需要不断修改已有代码，不仅会让这个函数越来越难维护，还可能因为修改带来一些 bug。所以为了解耦，需要使用策略模式，定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法（即策略）。

#### 示例

- [四季天气](10_strategy/main.go)：北京是一个四季分明的城市，每个季节天气情况都有明显特点。定义一个显示天气情况的季节接口，具体的四季实现，都会保存一个城市和天气情况的映射表。城市对象会包含季节接口，随着四季的变化，天气情况也随之变化。
- [Operator 配置 Strategy](30_strategy/20_strategy/main.go)

### 模板模式

模版模式（Template Pattern）定义一个操作中算法的骨架，而将一些步骤延迟到子类中。这种方法让子类在不改变一个算法结构的情况下，就能重新定义该算法的某些特定步骤。

简单来说，模板模式就是将一个类中能够公共使用的方法放置在抽象类中实现，将不能公共使用的方法作为抽象方法，强制子类去实现，这样就做到了将一个类作为一个模板，让开发者去填充需要填充的地方。

#### 示例

示例给出一种间接实现模板方法的方式，也比较符合模板方法模式的定义：

1. 将多个算法特定步骤组合成一个接口；
2. 基类隐式内嵌算法步骤接口，同时调用算法步骤接口的各方法，实现算法的模板方法，此时基类内嵌的算法步骤接口并没有真正的处理行为；
3. 子类隐式内嵌基类，并覆写算法步骤接口的方法；
4. 通过工厂方法创建具体子类，并将自己的引用赋值给基类中算法步骤接口字段；

- [演员模板](35_template/10_template/main.go)：以演员装扮为例，演员的装扮是分为化妆、穿衣、配饰 3 步骤。3 个步骤又根据不同角色的演员有所差别，因此演员基类实现装扮的模板方法。对于化妆、穿衣、配饰的 3 个步骤，在子类演员中具体实现，子类具体演员分为男演员、女演员和儿童演员。
- [Cook 模板](35_template/20_template/main.go)

```bash
go run main.go
```



### 访问者模式

访问者模式将算法与其所作用的对象隔离开来，允许在不修改已有代码的情况下向已有类层次结构中增加新的行为（通过 visitor 来添加）。

访问者接口需要根据被访问者具体类，定义多个相似的访问方法，每个具体类对应一个访问方法。每个被访问者需要实现一个接受访问者对象的方法，方法的实现就是去调用访问者接口对应该类的访问方法。这个接受方法可以传入不同目的访问者接口的具体实现，从而在不修改被访问对象的前提下，增加新的功能；

在[本示例](37_visiter/main.go)中，公司中存在多种类型的员工，包括产品经理、软件工程师、人力资源等，他们的 KPI 指标不尽相同。产品经理为上线产品数量及满意度，软件工程师为实现的需求数及修改 bug 数，人力资源为招聘员工的数量。公司要根据员工完成的 KPI 进行表彰公示，同时根据 KPI 完成情况定薪酬。这些功能都是员工类职责之外的，不能修改员工本身的类，通过访问者模式，实现 KPI 表彰排名及薪酬发放。

### 状态模式

状态模式能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。该模式将与状态相关的行为抽取到独立的状态类中，让原对象将工作委派给这些类的实例，而不是自行进行处理。

状态迁移由 4 个元素组成：起始状态、触发迁移的事件、终止状态以及要执行的动作。每个具体的状态包含触发状态迁移的执行方法，迁移方法的实现是执行持有状态对象的动作方法，同时设置状态为下一个流转状态。持有状态的业务对象包含有触发状态迁移方法，这些迁移方法将请求委托给当前具体状态对象的迁移方法。

在本示例中，IPhone 手机充电就是一个手机电池状态的流转。一开始手机处于有电状态，插入充电插头后，继续充电到满电状态，并进入断电保护，拔出充电插头后使用手机，由满电逐渐变为没电，最终关机。

**状态迁移表：**

| 起始状态 | 触发事件   | 终止状态 | 执行动作 |
| -------- | ---------- | -------- | -------- |
| 有电     | 插入充电线 | 满电     | 充电     |
| 有电     | 拔出充电线 | 没电     | 耗电     |
| 满电     | 插入充电线 | 满电     | 停止充电 |
| 满电     | 拔出充电线 | 有电     | 耗电     |
| 没电     | 插入充电线 | 有电     | 充电     |
| 没电     | 拔出充电线 | 没电     | 关机     |

### 备忘录模式

备忘录模式允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。备忘录不会影响它所处理的对象的内部结构，也不会影响快照中保存的数据。一般情况由原发对象保存生成的备忘录对象的状态不能被除原发对象之外的对象访问，所以通过内部类定义具体的备忘录对象是比较安全的。但 Go 不支持内部类定义的方式，因此 Go 实现备忘录对象时，首先将备忘录保存的状态设为非导出字段，避免外部对象访问，其次将原发对象的引用保存到备忘录对象中，当通过备忘录对象恢复时，直接操作备忘录的恢复方法，将备份数据状态设置到原发对象中，完成恢复。

示例

大家平时玩的角色扮演闯关游戏的存档机制就可以通过备忘录模式实现，每到一个关键关卡，玩家经常会先保存游戏存档，用于闯关失败后重置，存档会把角色状态及场景状态保存到备忘录中，同时将需要恢复游戏的引用存入备忘录，用于关卡重置；

### 观察者模式

观察者模式允许自定义一种订阅机制，可在对象事件发生时通知多个 “观察” 该对象的其他对象。观察者模式提供了一种作用于任何实现了订阅者接口的对象的机制，可对其事件进行订阅和取消订阅。观察者模式是最常用的模式之一是事件总线，分布式消息中间件等各种事件机制的原始理论基础，常用于解耦多对一的对象依赖关系。其增强的实现功能包括：

1. 当被观察者通过异步实现通知多个观察者时就相当于单进程实例的消息总线；
2. 同时还可以根据业务需要，将被观察者所有数据状态变更进行分类为不同的主题，观察者通过不同主题进行订阅；
3. 同一个主题又可分为增加、删除、修改事件行为；
4. 每个主题可以实现一个线程池，多个主题通过不同的线程池进行处理隔离，线程池可以设置并发线程大小、缓冲区大小及调度策略，比如先进先出，优先级等策略；
5. 观察者处理事件时有可能出现异常，所以也可以注册异常处理函数，异常处理也可以通过异常类型进行分类；
6. 根据业务需求也可以实现通知异常重试，延迟通知等功能；

[本示例]()描述信用卡业务消息提醒可通过观察者模式实现，业务消息包括日常消费、出账单、账单逾期，消息提醒包括短信、邮件及电话。根据不同业务的场景会采用不同的消息提醒方式或多种消息提醒方式，这里信用卡相当于被观察者，观察者相当于不同的通知方式。日常消费通过短信通知，出账单通过邮件通知，账单逾期三种方式都会进行通知。

### 中介者模式

中介者模式用来减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作，将网状依赖变为星状依赖。中介者能使得程序更易于修改和扩展，而且能更方便地对独立的组件进行复用，因为它们不再依赖于很多其他的类。

中介者模式与观察者模式之间的区别是，中介者模式解决的是同类或不同类的多个对象之间多对多的依赖关系，观察者模式解决的是多个对象与一个对象之间的多对一的依赖关系。

[本示例](45_mediator/main.go)描述机场塔台调度系统，假设是一个小机场，每次只能同时允许一架飞机起降，每架靠近机场的飞机需要先与塔台沟通是否可以降落。如果没有空闲的跑道，需要在天空盘旋等待。如果有飞机离港，等待的飞机会收到塔台的通知，按先后顺序降落。这种方式免去多架飞机同时到达机场需要相互沟通降落顺序的复杂性，减少多个飞机间的依赖关系、简化业务逻辑，从而降低系统出问题的风险。

### 迭代器模式

迭代器模式能在不暴露集合底层表现形式 （列表、 栈和树等）的情况下遍历集合中所有的元素。在迭代器的帮助下， 客户端可以用一个迭代器接口以相似的方式遍历不同集合中的元素。这里需要注意的是有两个典型的迭代器接口需要分清楚:一个是集合类实现的可以创建迭代器的工厂方法接口一般命名为 Iterable，包含的方法类似 CreateIterator；另一个是迭代器本身的接口，命名为 Iterator，有 Next 及 hasMore 两个主要方法.

#### 示例

[本示例](47_iterator/main.go)描述一个班级类中包括一个老师和若干个学生，要对班级所有成员进行遍历，班级中老师存储在单独的结构字段中，学生存储在另外一个 slice 字段中，通过迭代器可以实现统一遍历处理。

### 解释器模式

解释器模式用于描述如何使用面向对象语言构成一个简单的语言解释器。在某些情况下，为了更好地描述某一些特定类型的问题，可以创建一种新的语言，这种语言拥有自己的表达式和结构，即文法规则，这些问题的实例将对应为该语言中的句子。此时，可以使用解释器模式来设计这种新的语言。对解释器模式的学习能够加深对面向对象思想的理解，并且掌握编程语言中文法规则的解释过程。

在[本示例](50_interpreter/main.go)中，定义一个解析特征值的语句解释器，提供是否包含特征值的终结表达式，并提供或表达式与且表达式，同时，生成南极洲特征判断表达式，及美国人特征判断表达式，最后测试程序根据对象特征值描述，通过表达式判断是否为真。



### 命令模式

命令模式将请求转换为一个包含与请求相关的所有信息的独立对象。该转换能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。方法参数化是指将每个请求参数传入具体命令的工厂方法创建命令，同时具体命令会默认设置好接受对象，这样做的好处是不管请求参数个数及类型，还是接受对象有几个，都会被封装到具体命令对象的成员字段上，并通过统一的 Execute 接口方法进行调用，屏蔽各个请求的差异，便于命令扩展，多命令组装，回滚等。

#### 示例

[本示例]()控制电饭煲做饭是一个典型的命令模式的场景，电饭煲的控制面板会提供设置煮粥、蒸饭模式，及开始和停止按钮，电饭煲控制系统会根据模式的不同设置相应的火力，压强及时间等参数。煮粥、蒸饭就相当于不同的命令，开始按钮就相当命令触发器，设置好做饭模式，点击开始按钮电饭煲就开始运行，同时还支持停止命令。

### 责任链模式

责任链模式允许将请求沿着“处理者”链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。该模式允许多个对象来对请求进行处理，而无需让发送者类与具体接收者类相耦合。链可在运行时由遵循标准处理者接口的任意处理者动态生成。

一般意义上的责任链模式是说，请求在链上流转时任何一个满足条件的节点处理完请求后就会停止流转并返回，不过还可以根据不同的业务情况做一些改进：

1. 请求可以流经处理链的所有节点，不同节点会对请求做不同职责的处理；
2. 可以通过上下文参数保存请求对象及上游节点的处理结果，供下游节点依赖，并进一步处理；
3. 处理链可支持节点的异步处理，通过实现特定接口判断，是否需要异步处理；
4. 责任链对于请求处理节点可以设置停止标志位，不是异常，是一种满足业务流转的中断；
5. 责任链的拼接方式存在两种，一种是节点遍历，一个节点一个节点顺序执行；另一种是节点嵌套，内层节点嵌入在外层节点执行逻辑中，类似递归，或者“回”行结构；
6. 责任链的节点嵌套拼接方式多被称为拦截器链或者过滤器链，更易于实现业务流程的切面，比如监控业务执行时长，日志输出，权限校验等；

#### 示例

[本示例](54_chain/main.go)模拟实现机场登机过程，第一步办理登机牌，第二步如果有行李、办理托运，第三步核实身份，第四步安全检查，第五步完成登机。其中行李托运是可选的，其他步骤必选，必选步骤有任何不满足就终止登机。旅客对象作为请求参数上下文，每个步骤会根据旅客对象状态判断是否处理或流转下一个节点。

```bash
go run
```







## 行为型

结构型模式（Structural Pattern），它的特点是关注对象之间的通信。

### 代理模式

代理模式提供真实服务对象的替代品给客户端使用。 代理接收客户端的请求并进行一些处理 （访问控制和缓存等）， 然后再将请求传递给服务对象。Proxy 将对象嵌入其结构体，从而可通过 Proxy 的方法操作对象。代理对象拥有和服务对象相同的接口， 这使得当其被传递给客户端时可与真实对象互换。

修饰与代理是非常相似的设计模式，都是基于组合设计原则，也就是说一个对象应该将部分工作委派给另一个对象。但两者之间不同点我认为是，修饰器模式总是要执行服务对象，对于执行之前或执行之后结果进行加强，服务对象基本是客户端创建好再嵌套外层的修饰对象；而代理模式不一定执行服务对象，有可能通过缓存，延迟加载等没有访问服务对象，同时服务对象什么时候创建也是由代理类决定的。



- [代理模式](60_proxy/main.go)

```bash
go run 60_proxy/main.go
```

### 选项模式

Go 中的参数传递有多种方式。

#### 普通传参

Go 语言支持按顺序传入参数来调用函数，下面是一个示例函数：

```go
// ListApplications 查询应用列表
func ListApplications(limit, offset int) []Application {
	return allApps[offset : offset+limit]
}
```

调用代码：

```go
ListApplications(5, 0)
```

当想要增加新参数时，可以直接修改函数签名。比如，下面的代码给 `ListApplications` 增加了新的过滤参数 `owner`：

```go
func ListApplications(limit, offset int, owner string) []Application {
	if owner != "" {
		// ...
	}
	return allApps[offset : offset+limit]
}
```

调用代码也需要随之改变：

```go
ListApplications(5, 0, "wukong")
// 不使用 owner 过滤
ListApplications(5, 0, "")
```

显而易见，这种普通传参模式存在以下几个明显的缺点：

- 可读性不佳：只支持用位置，不支持用关键字来区分参数，参数变多后，各参数含义很难一目了然。
- 破坏兼容性：增加新参数后，原有调用代码必须进行对应修改，比如像上方的 `ListApplications(5, 0, "")` 一样，在 `owner` 参数的位置传递空字符串。

为了解决这些问题，常见的做法是引入一个参数结构体（struct）传参。

#### 可变传参

除了普通传参模式外，Go 还支持可变数量的参数，使用该特性的函数统称为“可变参数函数（varadic functions）”。比如 `append`、`fmt.Println` 均属此类。

```go
nums := []int{}
// 调用 append 时，传多少个参数都行 
nums = append(nums, 1, 2, 3, 4)
```

#### 结构体传参

新建一个结构体类型，里面包含函数需要支持的所有参数：

```go
// ListAppsOptions 是查询应用列表时的可选项
type ListAppsOptions struct {
	limit  int
	offset int
	owner  string
}
```

修改原函数，直接接收该结构体类型作为唯一参数：

```go
// ListApplications 查询应用列表，使用基于结构体的查询选项
func ListApplications(opts ListAppsOptions) []Application {
	if opts.owner != "" {
		// ...
	}
	return allApps[opts.offset : opts.offset+opts.limit]
}
```

调用代码如下所示：

```go
ListApplications(ListAppsOptions{limit: 5, offset: 0, owner: "wukong"})
ListApplications(ListAppsOptions{limit: 5, offset: 0})
```

相比普通模式，使用结构体传参有以下几个优势：

- 构建参数结构体时，可显式指定各参数的字段名，可读性佳。
- 对于非必选参数，构建时可不传值，比如上面省略了 `owner`。

##### 可选参数

不过，无论是使用普通传参还是结构体传参，都无法支持真正的可选参数。给 `ListApplications`  函数增加一个新选项：`hasDeployed`——根据应用是否已部署来过滤结果。

参数结构体调整如下：

```go
// ListAppsOptions 是查询应用列表时的可选项
type ListAppsOptions struct {
	limit       int
	offset      int
	owner       string
	hasDeployed bool
}
```

查询函数也做出对应调整：

```go
// ListApplications 查询应用列表，增加对 HasDeployed 过滤
func ListApplications(opts ListAppsOptions) []Application {
	// ...
	if opts.hasDeployed {
		// ...
	} else {
		// ...
	}
	return allApps[opts.offset : opts.offset+opts.limit]
}
```

想过滤已部署的应用时，可以调用：

```go
ListApplications(ListAppsOptions{limit: 5, offset: 0, hasDeployed: true})
```

而当不需要按“部署状态”过滤时，可以删除 `hasDeployed` 字段，用以下代码调用 `ListApplications` 函数：

```go
ListApplications(ListAppsOptions{limit: 5, offset: 0})
```

但问题在于 `hasDeployed` 是布尔类型，这意味着当不为其提供任何值时，程序总是会使用布尔类型的零值（zero value）：`false`。

所以，现在的代码其实根本拿不到“未按已部署状态过滤”的结果，`hasDeployed` 要么为 `true`，要么为 `false`，不存在其他状态。

##### 指针类型支持可选

为了解决上面的问题，最直接的做法是引入指针。和普通的值类型不同，Go 里的指针类型拥有一个特殊的零值：`nil`。因此，只要把 `hasDeployed`  从布尔类型（`bool`）改成指针类型（`*bool`），就能更好地支持可选参数：

```go
// ListAppsOptions 是查询应用列表时的可选项
type ListAppsOptions struct {
	limit  int
	offset int
	owner  string
	// 启用指针类型
	hasDeployed *bool
}
```

查询函数也需要做一些调整：

```go
// ListApplications 查询应用列表，增加对 HasDeployed 过滤
func ListApplications(opts ListAppsOptions) []Application {
	// ...
	if opts.hasDeployed == nil {
		// 默认不过滤分支
	} else {
		// 按 hasDeployed 为 true 或 false 来过滤
	}
	return allApps[opts.offset : opts.offset+opts.limit]
}
```

在调用函数时，调用方如不指定 `hasDeployed` 字段的值，代码就会进入 `if opts.hasDeployed == nil` 分支，不做任何过滤：

```go
ListApplications(ListAppsOptions{limit: 5, offset: 0})
```

当调用方想按 `hasDeployed` 过滤时，可以采用下面的方式：

```go
wantHasDeployed := true
ListApplications(ListAppsOptions{limit: 5, offset: 0, hasDeployed: &wantHasDeployed})
```

如所见，因为 `hasDeployed` 如今是指针类型 `*bool` ，所以必须得先创建一个临时变量，然后取它的指针去调用函数。不得不说，这挺麻烦的对不？有没有一种方式，既能解决前面这些函数传参时的痛点，又能让调用过程不要像“手动造指针”这么麻烦呢？接下来便该选项模式出场了。

#### 函数选项模式

选项模式（Options Pattern）是 Go 中经常使用到的模式，它以“参数设置函数”来代替结构体传递给函数。如 grpc/grpc-go 的 NewServer 函数，uber-go/zap 的 New 函数都用到了选项模式。使用选项模式，可以创建一个带有默认值的 struct 变量，并选择性地修改其中一些参数的值。

为了实现“函数式选项”模式，首先修改 `optionFunc` 函数的签名，使其接收类型为 `func(*options)` 的可变数量参数。

```go
type optionFunc func(*options)

func (f optionFunc) apply(o *options) {
    f(o)
}
```

然后，再定义一系列用于设置选项的参数设置函数，这些以 `With*` 命名，通过返回闭包函数来修改函数选项对象 `Option`。

```go
func WithTimeout(t time.Duration) Option {
    return optionFunc(func(o *options) {
        o.timeout = t
    })
}

func WithCaching(cache bool) Option {
    return optionFunc(func(o *options) {
        o.caching = cache
    })
}
```

调用时的代码如下：

```go
// 不使用任何参数
NewConnect()
// 选择性启用某些选项
NewConnect(WithTimeout(8))
NewConnect(WithTimeout(8), WithCachine(true))
```

Option 类型的选项参数需要实现 apply(*options) 函数，结合 WithTimeout、WithCaching 函数的返回值和 optionFunc 的 apply 方法实现，可以知道 o.apply(&options) 其实就是把 WithTimeout、WithCaching 传入的参数赋值给 options 结构体变量，以此动态地设置 options 结构体变量的属性。和使用“结构体传参”相比，“选项模式”有以下几个特点：

- 更友好的可选参数：比如不再需要手动为 `hasDeployed` 取指针。
- 灵活性更强：可以方便地在每个 `With*` 函数里追加额外逻辑。
- 向前兼容性好：任意增加新的选项都不会影响已有代码。
- 更漂亮的 API：当参数结构体很复杂时，该模式所提供的 API 更漂亮，也更好用。



### 适配器模式

适配器模式是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。适配器可担任两个对象间的封装器， 它会接收对于一个对象的调用， 并将其转换为另一个对象可识别的格式和接口。

在[本示例]()中，通过充电宝给不同充电接口的手机充电是一个非常符合适配器模式特征的生活示例；一般充电宝提供USB电源输出接口，手机充电输入接口则分为两类一是苹果手机的lightning接口，另一类是安卓手机的typeC接口，这两类接口都需要通过适配电源线连接充电宝的USB接口，这里USB接口就相当于充电宝的通用接口，lightning或typeC接口要想充电需要通过充电线适配。

### 桥接模式

桥接模式将业务逻辑或一个大类拆分为不同的层次结构，从而能独立地进行开发。

层次结构中的第一层 （通常称为抽象部分） 将包含对第二层 （实现部分） 对象的引用。 抽象部分将能将一些（有时是绝大部分）对自己的调用委派给实现部分的对象。 所有的实现部分都有一个通用接口， 因此它们能在抽象部分内部相互替换。简单的说，一个事物存在多个维度的变化点，每一个维度都抽象出一个接口，事物引用这些接口实现整体行为逻辑，而每一个接口都可以存在多个变化的实现。更简单的一句话：依赖接口编程。

[本示例](66_bridge/main.go)中，对于一段经历的描述，经历就可能有多种实现，比如旅游经历。探险经历这相当于第一层次的类结构，同时描述旅游经历或探险经历又包含多个维度，比如如何到达目的地、在目的地开展了什么活动等。到达目的地有很多种方式，比如飞机、火车、汽车等。开展的活动又根据地点不同而不同，海边可以冲浪、山地可以攀岩、荒漠可以徒步穿越等。这两个维度的变化点对于描述经历来说相当于第二层次类实现，通过接口被第一层次引用。这里对于经历描述存在三个维度的变化：

1. 经历本身的两个实现：旅游经历与探险经历。
2. 交通方式的两个实现：飞机和汽车。
3. 开展活动的三个实现：冲浪、攀岩与徒步穿越。

### 组合模式

组合模式可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。对于绝大多数需要生成树状结构的问题来说，组合都是非常受欢迎的解决方案。组合最主要的功能是在整个树状结构上递归调用方法并对结果进行汇总。

[本示例](68_composte/main.go)中，一般来说一个地区统计人口或经济总量，总是通过行政区划一层层上报汇总得出结果。区镇是最低一级行政区划，需要落实统计人口及经济总量的工作，再上一级行政区划需要将所辖区镇的数据汇总统计，以此类推每一级行政区划都需要统计人口与经济总量。就像一个倒过来的树状结构，各级行政区划统一的组件接口是统计人口与经济总量，区镇相当于最底层的叶子节点，中间级别行政区划相当于组合节点，示例中的代码以苏州市为例。

### 装饰模式

装饰模式通过将对象放入特殊封装对象中来为原对象增加新的行为。由于目标对象和装饰器遵循同一接口， 因此可用装饰来对对象进行无限次的封装，结果对象将获得所有封装器叠加而来的行为。

在[本示例](70_decorator/main.go)中，地铁进站的过程一般情况下只需要买票、检票进站，但是如果带行李，就需要进行安全检查。如果是疫情时期，就需要进行疫情防护检查，比如戴口罩、测量体温等。这里买票进站相当于通用进站流程，安检及防疫检查就相当于加强的修饰行为。

### 外观模式

外观是一种结构型设计模式，能为复杂系统、程序库或框架提供一个简单（但有限）的接口。尽管外观模式降低了程序的整体复杂度， 但它同时也有助于将不需要的依赖移动到同一个位置。

在[本示例](72_facase/main.go)中，用户在淘宝电商系统买商品时，只需要选好商品在结算页点击提交即可完成下单。在客户端系统仅需要一个创建订单的方法，但是整个订单的生成需要很多步骤，比如查询用户配送地址、查询商品价格、使用优惠券、扣减商品库存、支付相应价钱等。

### 享元模式

享元模式允许在消耗少量内存的情况下支持大量对象，该模式通过共享多个对象的部分状态来实现上述功能。 换句话来说， 享元会将不同对象的相同数据进行缓存以节省内存。

在[本示例](74_flyweight/main.go)中，北京出租车调度系统，需要每隔一分钟记录一下全市出租车的位置信息。假设为了提高系统响应速度，近一天的数据需要存储在内存中。每个位置信息包括出租车辆信息及位置信息，位置信息在系统中就是一个(x,y)坐标，车辆信息包括车的号牌、颜色、品牌和所属公司。在调度系统存储的出租车行驶轨迹中，位置是实时在变化的，但车辆信息就可以通过享元模式共用一个对象引用，来减少内存消耗。

## 额外

### SchemeBuilder

- [SchemeBuilder](88_scheme-builder/README.md)

